# Instructions for the project
-General description: How the program is used and to what purpose and describtion of user interface especially form those parts that are not self-evident.
-Structure of the program
-Secure programming solutions: How and in which parts of the code? You should also comment the code itself. You should use a checklist, for example OWASP TOP 10 or SANS 25. Describe how issues have been solved.
-In case the program is based on earlier work, report the changes
-You should include at least manual security testing, but it is highly recommended to do more extensive testing. Report testing and also what you found and what you fixed based on testing. If you made the DevSecOps exercise it is a good idea to use the pipeline throughout the programming project.
-In case something was not yet implemented, document that as well.
-If you know there is security issue or vulnerability, document that as well.
-Suggestions for improvement, what could be implemented.


## Secure Programming Coursework
This is a project for the Secure Programming course at the University of Tampere. The goal of this project was to create a secure API gateway that communicates 
with a backend service. The scope was to focus on rate limiting, monitoring and finding a way to provide public endpoints for mobile clients - in a way that login action
is not needed but so that clients can be blacklisted if needed. The project was implemented using Java and Spring Boot, with a focus on security best practices and principles.

Scope was created with the primary goal of exploring new advancements in gateway security features.

### Parts
- API Gateway: The main entry point for clients to access the backend service. It handles authentication, rate limiting, and monitoring.
- Backend Service: The service that the API Gateway communicates with. It handles the actual business logic and data processing. This is just a dummy service for testing purposes.
- Common Library: A shared library that contains common code used by both the API Gateway and the backend service. This includes utility functions, data models, and security-related code.
- Docker Compose: A configuration file for Docker Compose that defines the services, networks, and volumes used in the project. This allows for easy deployment and management of the services.
- Grafana and Prometheus: Monitoring tools used to visualize and analyze the performance of the API Gateway and backend service. Grafana is used for creating dashboards and visualizations, while Prometheus is used for collecting and storing metrics.
- Postman: A tool used for testing and interacting with the API. It allows for easy testing of endpoints, sending requests, and viewing responses. Postman collections are included in the project for easy testing of the API Gateway and backend service.
- Unit Tests: A set of unit tests for the API Gateway and backend service. These tests cover various aspects of the code, including security and functionality. The tests are run using JUnit and Mockito.
- Integration Tests: A set of integration tests for the API Gateway and backend service. These tests cover the interaction between the two services, ensuring that they work together as expected. The tests are run using Spring Boot Test and Mockito.
- Security Testing: A set of security tests for the API Gateway. The tests are run using OWASP ZAP and CodeQL static application security testing.

## API Gateway
Gateway is the main entry point for clients to access the backend service. It handles authentication, rate limiting, and monitoring. The API Gateway is implemented using Spring Boot and Java.
It is a Spring Cloud Gateway project. Routing for endpoints is implemented in GatewayConfig, there are endpoints for public usage and for admin usage. Rate limiting
is implemented using Redis and Spring Cloud Gateway's built-in rate limiting features. Endpoints created for mobile client use the mobile client UUID for rate limiting, to count
requests per client and admin endpoints use ip-address. Mobile clients are registered using a registration endpoint, that is called by the mobile client, where POST request
is expected to contain an UUID and a base64 encoded 32-byte key for authentication. UUID and key are saved to the database (key is saved as encrypted using AES encryption)
and the authenticity of the later requests is verified using HMAC-SHA256 signing: requests must contain the UUID, a timestamp, and a signature in the header. The signature is generated by concatenating the UUID and timestamp with a colon, 
and then signing it using HMAC-SHA256 with the shared secret key. Requests that do not contain the correct signature and the UUID is not saved as an active device are rejected. 


The API Gateway also includes monitoring and logging features, which are implemented using Micrometer and Prometheus. Request and responses are logged, without sensitive data, 
and metrics are collected and sent to Prometheus for monitoring. There is also a UsageTimeTrackingFilter to track the time taken for each request and response so
that requests coming on unusual times can be detected. There is also a Grafana dashboard included in the project for visualizing the metrics and monitoring the performance of the API Gateway.

# How to run the project

## Clone the repository

## Install Docker and Docker Compose

## Add values to .env file, for example:
```
DB_HOST=db
DB_PORT=5432
DB_NAME=product-db
DB_USERNAME=myuser
DB_PASSWORD=mypassword
REDIS_PASSWORD=mypassword
REDIS_HOST=redis
REDIS_PORT=6379
ENCRYPTION_KEY=
GF_SECURITY_ADMIN_USER=admin
GF_SECURITY_ADMIN_PASSWORD=admin
```

Encryption key is used for AES encryption and decryption of the secret key. It should be a 32-byte base64 encoded string.
It can be generated using the following command:
```bash
openssl rand -base64 32
```

## Build the project
```bash
./gradlew build
```

## Run the project using Docker Compose
```bash
docker-compose up --build -d
```

## Using the application
There is a json file included in the project for Postman, which contains the endpoints and example requests.

Grafana can be accessed at http://localhost:3000 and the default username and password are admin/admin. There is a dashboard configured that uses Prometheus as the data source.


# Quality control
There is a CI pipeline using github actions that builds the program, runs unit tests and SAST. 

DAST was run locally and can be run using the following command:
```bash
docker pull zaproxy/zap-stable
docker run --network coursework_mynetwork -v ${PWD}:/zap/wrk/:rw -t zaproxy/zap-stable zap-api-scan.py `
>>   -f openapi -t /zap/wrk/openapi.yaml -r zap-report.html
```
For the purpose of the project and it's grading, results from the first run can be found as a PDF in the project. Obviously in the real world,
it probably would not be wise to publish report publicly.


## Security

### OWASP API Top 10

Application doesn't have any functionality where *object level authorization* is needed. If necessary in the future, there could be authenticated users how were the only one's allowed to add products and editing or removing the products should have a verification that the request is made by the same user how owns the product. 

Gateway is providing public endpoints, identifying API client using hmac signed requests and allowed device registry. UUID and the client secret is required to be long. AES is used to encrypt each client key before saving to database. Even though authentication is out of the scope of this project, client identification is done by following good practices. It would be smart to force clients rotating the secrets regularly.

Returning only DTO objects is a simple yet effective way to prevent broken object property level authorization - by including only non-sensitive fields in objects used in responses. 

Rate limiting is implemented to prevent denial of service attacks. Data models have maxium limits. Only requests with valid input are allowed, incorrect field names or additional fields in ProductDTO's will throw an exception.

There is currently no authentication or authorization, but all the admin endpoints are under /admin/ path and filter can be easily added in GatewayConfig to those endpoints.

As the actual API of the application is only a dummy application to test the gateway, there is no harm of violating business flows. In a real word application, this could be avoided using filters in gateway as well as other checks in the application side by first identifying sensitive flows. White and black listing devices that is implemented in a gateway is a one way to help.

Server Side Request Forgery is not possible in current application. Products could easily though have pictures that could be added using url's of the photos and security measures should then be applied.

Software is intended to expose as little as possible but it is suggested to keep reviewing configurations continuously. Trivy filescan was done and results are in the repository to help to identify vulnerabilities. Obviously it is not sensible to publish results in a real project.

When going into production it is important to keep the documentation up to date. The documentation should include information about the endpoints, request and response formats, and any authentication or authorization requirements.

If the API used in the project wasn't our own - it would be necessary to validate and sanitize responses in the GatewayConfig. 


# Future improvements
